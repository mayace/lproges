package com.github.lproges.gui;

import com.github.lproges.compiler.Attr;
import com.github.lproges.compiler.Err;
import com.github.lproges.compiler.Nodo;
import com.github.lproges.compiler.Sim;
import com.github.lproges.compiler.es.Parser;
import com.github.lproges.compiler.es.Scanner;
import java.io.IOException;
import java.io.PrintWriter;
import java.io.StringReader;
import java.nio.file.FileAlreadyExistsException;
import java.nio.file.Files;
import java.nio.file.OpenOption;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.nio.file.StandardOpenOption;
import java.text.MessageFormat;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.LinkedList;
import java.util.logging.Level;
import java.util.logging.Logger;

public class Win extends javax.swing.JFrame {

    /**
     * Creates new form Win
     */
    public Win() {
        initComponents();
    }

    /**
     * This method is called from within the constructor to initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is always
     * regenerated by the Form Editor.
     */
    @SuppressWarnings("unchecked")
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {

        tabPane1 = new com.github.lproges.editor.gui.TabPane();
        menuBar = new javax.swing.JMenuBar();
        fileMenu = new javax.swing.JMenu();
        newMenuItem = new javax.swing.JMenuItem();
        openMenuItem = new javax.swing.JMenuItem();
        saveMenuItem = new javax.swing.JMenuItem();
        saveAsMenuItem = new javax.swing.JMenuItem();
        exitMenuItem = new javax.swing.JMenuItem();
        editMenu = new javax.swing.JMenu();
        cutMenuItem = new javax.swing.JMenuItem();
        copyMenuItem = new javax.swing.JMenuItem();
        pasteMenuItem = new javax.swing.JMenuItem();
        deleteMenuItem = new javax.swing.JMenuItem();
        compilerMenu = new javax.swing.JMenu();
        compile3Menu = new javax.swing.JMenuItem();
        jSeparator1 = new javax.swing.JPopupMenu.Separator();
        compileMenu = new javax.swing.JMenuItem();
        symtableMenu = new javax.swing.JMenuItem();
        errorMenu = new javax.swing.JMenuItem();
        optimizerMenu = new javax.swing.JMenu();
        grafoMenu = new javax.swing.JMenuItem();
        jSeparator2 = new javax.swing.JPopupMenu.Separator();
        bloqueMenu = new javax.swing.JMenuItem();
        mirillaMenu = new javax.swing.JMenuItem();
        helpMenu = new javax.swing.JMenu();
        contentsMenuItem = new javax.swing.JMenuItem();
        aboutMenuItem = new javax.swing.JMenuItem();

        setDefaultCloseOperation(javax.swing.WindowConstants.EXIT_ON_CLOSE);
        setTitle("TextEditor");
        setPreferredSize(new java.awt.Dimension(1024, 600));
        getContentPane().add(tabPane1, java.awt.BorderLayout.CENTER);

        fileMenu.setMnemonic('f');
        fileMenu.setText("File");

        newMenuItem.setAccelerator(javax.swing.KeyStroke.getKeyStroke(java.awt.event.KeyEvent.VK_N, java.awt.event.InputEvent.CTRL_MASK));
        newMenuItem.setText("New");
        newMenuItem.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                newMenuItemActionPerformed(evt);
            }
        });
        fileMenu.add(newMenuItem);

        openMenuItem.setAccelerator(javax.swing.KeyStroke.getKeyStroke(java.awt.event.KeyEvent.VK_O, java.awt.event.InputEvent.CTRL_MASK));
        openMenuItem.setMnemonic('o');
        openMenuItem.setText("Open");
        openMenuItem.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                openMenuItemActionPerformed(evt);
            }
        });
        fileMenu.add(openMenuItem);

        saveMenuItem.setAccelerator(javax.swing.KeyStroke.getKeyStroke(java.awt.event.KeyEvent.VK_S, java.awt.event.InputEvent.CTRL_MASK));
        saveMenuItem.setMnemonic('s');
        saveMenuItem.setText("Save");
        saveMenuItem.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                saveMenuItemActionPerformed(evt);
            }
        });
        fileMenu.add(saveMenuItem);

        saveAsMenuItem.setAccelerator(javax.swing.KeyStroke.getKeyStroke(java.awt.event.KeyEvent.VK_S, java.awt.event.InputEvent.SHIFT_MASK | java.awt.event.InputEvent.CTRL_MASK));
        saveAsMenuItem.setMnemonic('a');
        saveAsMenuItem.setText("Save As ...");
        saveAsMenuItem.setDisplayedMnemonicIndex(5);
        saveAsMenuItem.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                saveAsMenuItemActionPerformed(evt);
            }
        });
        fileMenu.add(saveAsMenuItem);

        exitMenuItem.setAccelerator(javax.swing.KeyStroke.getKeyStroke(java.awt.event.KeyEvent.VK_Q, java.awt.event.InputEvent.CTRL_MASK));
        exitMenuItem.setMnemonic('x');
        exitMenuItem.setText("Exit");
        exitMenuItem.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                exitMenuItemActionPerformed(evt);
            }
        });
        fileMenu.add(exitMenuItem);

        menuBar.add(fileMenu);

        editMenu.setMnemonic('e');
        editMenu.setText("Edit");

        cutMenuItem.setAccelerator(javax.swing.KeyStroke.getKeyStroke(java.awt.event.KeyEvent.VK_X, java.awt.event.InputEvent.CTRL_MASK));
        cutMenuItem.setMnemonic('t');
        cutMenuItem.setText("Cut");
        editMenu.add(cutMenuItem);

        copyMenuItem.setAccelerator(javax.swing.KeyStroke.getKeyStroke(java.awt.event.KeyEvent.VK_C, java.awt.event.InputEvent.CTRL_MASK));
        copyMenuItem.setMnemonic('y');
        copyMenuItem.setText("Copy");
        editMenu.add(copyMenuItem);

        pasteMenuItem.setAccelerator(javax.swing.KeyStroke.getKeyStroke(java.awt.event.KeyEvent.VK_V, java.awt.event.InputEvent.CTRL_MASK));
        pasteMenuItem.setMnemonic('p');
        pasteMenuItem.setText("Paste");
        editMenu.add(pasteMenuItem);

        deleteMenuItem.setMnemonic('d');
        deleteMenuItem.setText("Delete");
        editMenu.add(deleteMenuItem);

        menuBar.add(editMenu);

        compilerMenu.setText("Compilador");

        compile3Menu.setAccelerator(javax.swing.KeyStroke.getKeyStroke(java.awt.event.KeyEvent.VK_3, java.awt.event.InputEvent.CTRL_MASK));
        compile3Menu.setText("Compile TAC");
        compilerMenu.add(compile3Menu);
        compilerMenu.add(jSeparator1);

        compileMenu.setAccelerator(javax.swing.KeyStroke.getKeyStroke(java.awt.event.KeyEvent.VK_P, java.awt.event.InputEvent.CTRL_MASK));
        compileMenu.setText("Compilar");
        compileMenu.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                compileMenuActionPerformed(evt);
            }
        });
        compilerMenu.add(compileMenu);

        symtableMenu.setAccelerator(javax.swing.KeyStroke.getKeyStroke(java.awt.event.KeyEvent.VK_T, java.awt.event.InputEvent.CTRL_MASK));
        symtableMenu.setText("MostrarTabla de Simbolos");
        symtableMenu.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                symtableMenuActionPerformed(evt);
            }
        });
        compilerMenu.add(symtableMenu);

        errorMenu.setAccelerator(javax.swing.KeyStroke.getKeyStroke(java.awt.event.KeyEvent.VK_E, java.awt.event.InputEvent.CTRL_MASK));
        errorMenu.setText("Mostrar Errores");
        errorMenu.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                errorMenuActionPerformed(evt);
            }
        });
        compilerMenu.add(errorMenu);

        menuBar.add(compilerMenu);

        optimizerMenu.setText("Optimizador");

        grafoMenu.setText("Mostrar Grafo de Flujo");
        optimizerMenu.add(grafoMenu);
        optimizerMenu.add(jSeparator2);

        bloqueMenu.setText("Optimizar por Bloques");
        optimizerMenu.add(bloqueMenu);

        mirillaMenu.setText("Optimizar por Mirilla");
        optimizerMenu.add(mirillaMenu);

        menuBar.add(optimizerMenu);

        helpMenu.setMnemonic('h');
        helpMenu.setText("Help");

        contentsMenuItem.setMnemonic('c');
        contentsMenuItem.setText("Contents");
        helpMenu.add(contentsMenuItem);

        aboutMenuItem.setMnemonic('a');
        aboutMenuItem.setText("About");
        helpMenu.add(aboutMenuItem);

        menuBar.add(helpMenu);

        setJMenuBar(menuBar);

        pack();
    }// </editor-fold>//GEN-END:initComponents

    private void exitMenuItemActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_exitMenuItemActionPerformed
        System.exit(0);
    }//GEN-LAST:event_exitMenuItemActionPerformed

    private void newMenuItemActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_newMenuItemActionPerformed
        try {
            tabPane1.nuevo();
        } catch (IOException ex) {
            Logger.getLogger(Win.class.getName()).log(Level.SEVERE, null, ex);
        }
    }//GEN-LAST:event_newMenuItemActionPerformed

    private void openMenuItemActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_openMenuItemActionPerformed
        try {
            tabPane1.abrir();
        } catch (IOException ex) {
            Logger.getLogger(Win.class.getName()).log(Level.SEVERE, null, ex);
        }
    }//GEN-LAST:event_openMenuItemActionPerformed

    private void saveMenuItemActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_saveMenuItemActionPerformed
        try {
            // TODO add your handling code here:
            tabPane1.guardar();
        } catch (IOException ex) {
            Logger.getLogger(Win.class.getName()).log(Level.SEVERE, null, ex);
        }
    }//GEN-LAST:event_saveMenuItemActionPerformed

    private void saveAsMenuItemActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_saveAsMenuItemActionPerformed
        try {
            tabPane1.guardarComo();
        } catch (IOException ex) {
            Logger.getLogger(Win.class.getName()).log(Level.SEVERE, null, ex);
        }
    }//GEN-LAST:event_saveAsMenuItemActionPerformed

    private void compileMenuActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_compileMenuActionPerformed
        // TODO add your handling code here:
        String text = tabPane1.getText();

        if (text != null && !text.trim().isEmpty()) {
            StringReader input = new StringReader(text);
            Scanner s = new Scanner(input);
            Parser p = new Parser(s);
            try {
                p.parse();
                // procesar el resultado obtenido por el commpilador
                process_result(s, p);
            } catch (Exception ex) {
                Logger.getLogger(Win.class.getName()).log(Level.SEVERE, null, ex);
            }
        }
    }

    public void process_result(Scanner scanner, Parser parser) {
        // pre operaciones
        // errores
        LinkedList<Err> errores = new LinkedList<>();
        errores.addAll(scanner.getErrores());
        errores.addAll(parser.getErrores());

        // init
        Nodo.CompilerStuff cstuff = getCompilerStuffs(errores);
        HashMap<Object, Nodo.Operation> operaciones = getOperaciones();

        if (errores.isEmpty()) {
            // sin errores

            // procesar nodos
            LinkedList<Nodo> nodos = parser.getNodos();
            for (Nodo nodo : nodos) {
                nodo.exec(cstuff, operaciones);
            }
            // procesar resultados del nodo
            if (cstuff.getErrors().isEmpty()) {
                Path file = Paths.get("3dir.cpp");
                // limpiar archivo
                write_file(file, "", StandardOpenOption.CREATE, StandardOpenOption.TRUNCATE_EXISTING);
                // escribir texto 3dir generado por cada nodo
                for (Nodo nodo : nodos) {
                    Attr nodo_attr = (Attr) nodo.getVal();
                    String nodo_tres = nodo_attr.getString("tres");
                    write_file(file, nodo_tres, StandardOpenOption.APPEND);
                }
            } else {
                // con errores
                for (Err err : errores) {
                    err.println();
                }
            }
        } else {
            // con errores
            for (Err err : errores) {
                err.println();
            }
        }

        // post operaciones
        // carga errores
        gui_errors.getTabla().setModel(cstuff.get_errors_tablemodel());
        // cargar tabla de simbolos
        gui_simtable.getTabla().setModel(cstuff.get_symtable_tablemode());
    }//GEN-LAST:event_compileMenuActionPerformed

    private void symtableMenuActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_symtableMenuActionPerformed
        // TODO add your handling code here:
        gui_simtable.setVisible(true);
    }//GEN-LAST:event_symtableMenuActionPerformed

    private void errorMenuActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_errorMenuActionPerformed
        // TODO add your handling code here:
        gui_errors.setVisible(true);
    }//GEN-LAST:event_errorMenuActionPerformed

    public void write_file(Path file, String write, OpenOption... ooptions) {
        try {
            Files.write(file, write.getBytes(), ooptions);
        } catch (IOException ex) {
            Logger.getLogger(Win.class.getName()).log(Level.SEVERE, null, ex);
        }
    }

    public Nodo.CompilerStuff getCompilerStuffs(LinkedList<Err> errors) {
        final int[] stack = new int[100];
        final int[] heap = new int[100];
        HashMap<Object, Sim> symtable = new HashMap<>();
        LinkedList<Err> errores = (errors == null ? new LinkedList<Err>() : errors);

        Nodo.CompilerStuff cosas_compildor = new Nodo.CompilerStuff(stack, heap, symtable, errores);
        return cosas_compildor;
    }

    public HashMap<Object, Nodo.Operation> getOperaciones() {
        HashMap<Object, Nodo.Operation> operaciones = new HashMap<>();
        // definicion de las operaciones soportadas 
        Nodo.Operation declaracion = new Nodo.Operation("declaracion") {

            @Override
            public void exec(Nodo nodo, Nodo.CompilerStuff compiler, Object operations) {
                Attr l_val = (Attr) nodo.getLeft().getVal();

                // estructura definida para val (info,tipo,val)
                Attr l_val_val = l_val.getAttr("val");

                // estructura enviada por la gramatica
                Attr tipo_attr = l_val_val.getAttr("tipo");
                ArrayList<Attr> var_list = l_val_val.getList("list");
                String scope = l_val_val.getString("scope");

                // procesando estructura enviada por la gramatica
                String tipo_val = tipo_attr.getString("val");

                for (Attr var_attr : var_list) {
                    String var_val = var_attr.getString("val");
                    Object var_info = var_attr.get("info");

                    // procesando variable
                    if (compiler.existsKey(scope, var_val)) {
                        compiler.addError(new Err("Ya existe la variable: " + var_val, var_info, Err.TIPO.SEMANTICO));
                    } else {
                        compiler.addVar(scope, var_val, tipo_val, "variable", 1);
                    }
                }

            }
        };

        Nodo.Operation method = new Nodo.Operation("method") {

            @Override
            public void exec(Nodo nodo, Nodo.CompilerStuff compiler, Object operations) {
                Attr val = new Attr();
                Attr l_val = (Attr) nodo.getLeft().getVal();

                String val_tres = "";

                if (l_val != null) {
                    // datos del val
                    Attr l_val_val = l_val.getAttr("val");
                    // datos enviada por la gramatica
                    String method_scope = l_val_val.getString("scope");
                    Attr method_tipo_attr = l_val_val.getAttr("tipo");
                    Attr method_id_attr = l_val_val.getAttr("id");
                    ArrayList<Attr> method_param_list = l_val_val.getList("list");
                    String method_tipo_list = l_val_val.getString("tipo_list");
                    // procesar metodo
                    String method_tipo_val = method_tipo_attr.getString("val");
                    String method_id_val = method_id_attr.getString("val");
                    Object method_id_info = method_id_attr.get("info");
                    String method_var_scope = (method_scope.isEmpty() ? "" : method_scope + ".") + method_id_val + "," + method_tipo_list;
                    String method_tres = String.format("// METODO {0}\n", method_id_val);
                    //procesar parametros
                    boolean method_param_ok = true;
                    for (int i = 0; i < method_param_list.size(); i++) {
                        Attr param_attr = method_param_list.get(i);
                        Attr param_id_attr = param_attr.getAttr("id");
                        Attr param_tipo_attr = param_attr.getAttr("tipo");
                        String param_name = param_id_attr.getString("val");
                        Object param_info = param_id_attr.get("info");
                        String param_tipo = param_tipo_attr.getString("val");

                        if (compiler.existsKey(method_var_scope, param_name)) {
                            compiler.addError(new Err("Ya existe el parametro:" + param_name, param_info, Err.TIPO.SEMANTICO));
                            method_param_ok = false;
                            break;
                        } else {
                            compiler.addVar(method_var_scope, param_name, param_tipo, "parametro", 1);
                        }

                    }

                    if (method_param_ok) {
                        // verificar la existencia del metodo
                        Object[] method_tipo_array = method_tipo_list.split("\\.");
                        if (compiler.existsKey(method_scope, method_id_val, method_tipo_array)) {
                            compiler.addError(new Err("Ya existe el metodo: " + method_id_val, method_id_info, Err.TIPO.SEMANTICO));
                        } else {
                            compiler.addMethod(method_scope, method_id_val, method_tipo_val, method_tipo_array);
                        }
                    } else {
                        // error de parametros
                    }

                    // crear codigo tres direcciones
                    val_tres = method_tres;
                }

                // enviar el resultado
                // una definicion de metodo no retorna nada... solo tres dircciones
                val.set("tipo", null);
                val.set("info", null);
                val.set("val", null);
                val.set("tres", val_tres);
                nodo.setVal(val);
            }
        };

        Nodo.Operation declaracion_array = new Nodo.Operation("declaracion_array") {

            @Override
            public void exec(Nodo nodo, Nodo.CompilerStuff compiler, Object operations) {
                Attr val = new Attr();
                // obteniendo informacion
                Attr l_val = (Attr) nodo.getLeft().getVal();
                // estructura val (tipo,info,val)
                Attr l_val_val = l_val.getAttr("val");
                
                // estructura enviada por la gramatica
                String array_scope = l_val_val.getString("scope");
                Attr array_tipo_attr = l_val_val.getAttr("tipo");
                Attr array_id_attr = l_val_val.getAttr("id");
                ArrayList<Attr> array_dimension_list = l_val_val.getList("list");
                
                // procesando informacion
                String array_tipo_val = array_tipo_attr.getString("val");
                final String array_id_val = array_id_attr.getString("val");
                final Object array_id_info = array_id_attr.get("info");
                final Object array_key = compiler.getKey(array_scope, array_id_val);

                // verificando existencia de simbolo
                if (compiler.getSimtable().containsKey(array_key)) {
                    compiler.getErrors().add(new Err("Ya existe la variable: " + array_id_val, array_id_info, Err.TIPO.SEMANTICO));
                } else {
                    // obtencion del tamanio del arreglo
                    int array_size = 1;
                    for (Attr attr : array_dimension_list) {
                        // ejecutar la expresion
                        final Nodo d_nodo = attr.getNodo("nodo");
                        d_nodo.exec(compiler, operations);
                        // obteniendo el resultado
                        Attr d_val = (Attr) d_nodo.getVal();
                        Attr d_val_val = d_val.getAttr("val");
                        String d_tipo = d_val.getString("tipo");
                        if (d_tipo.equals("int")) {
                            Integer d_size = d_val.getInteger("val");
                            array_size *= d_size;
                        } else {
                            // error en resultado de la expresion
                            compiler.getErrors().add(new Err("Se esperaba un entero....", array_id_info, Err.TIPO.SEMANTICO));
                            break;
                        }
                    }
                    // procesando resultado
                    if (compiler.getErrors().isEmpty()) {
                        // creando simbolo
                        compiler.addVar(array_scope, array_id_val, array_tipo_val, "arreglo", array_size);
                    }
                }

                
                // enviar resultado
                val.set("tipo",null);
                val.set("val", null);
                val.set("info",null);
                
                nodo.setVal(val);
            }

        };

        // registro de las operaciones
        operaciones.put(method.getId(), method);
        operaciones.put(declaracion.getId(), declaracion);
        operaciones.put(declaracion_array.getId(), declaracion_array);
        return operaciones;
    }

    /**
     * @param args the command line arguments
     */
    public static void main(String args[]) {
        /* Set the Nimbus look and feel */
        //<editor-fold defaultstate="collapsed" desc=" Look and feel setting code (optional) ">
        /* If Nimbus (introduced in Java SE 6) is not available, stay with the default look and feel.
         * For details see http://download.oracle.com/javase/tutorial/uiswing/lookandfeel/plaf.html 
         */
        try {
            for (javax.swing.UIManager.LookAndFeelInfo info : javax.swing.UIManager.getInstalledLookAndFeels()) {
                if ("Nimbus".equals(info.getName())) {
                    javax.swing.UIManager.setLookAndFeel(info.getClassName());
                    break;
                }
            }
        } catch (ClassNotFoundException ex) {
            java.util.logging.Logger.getLogger(Win.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        } catch (InstantiationException ex) {
            java.util.logging.Logger.getLogger(Win.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        } catch (IllegalAccessException ex) {
            java.util.logging.Logger.getLogger(Win.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        } catch (javax.swing.UnsupportedLookAndFeelException ex) {
            java.util.logging.Logger.getLogger(Win.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        }
        //</editor-fold>

        /* Create and display the form */
        java.awt.EventQueue.invokeLater(new Runnable() {
            public void run() {
                final Win win = new Win();
                win.setVisible(true);
                win.setLocationRelativeTo(null);
            }
        });
    }

    // Variables declaration - do not modify//GEN-BEGIN:variables
    private javax.swing.JMenuItem aboutMenuItem;
    private javax.swing.JMenuItem bloqueMenu;
    private javax.swing.JMenuItem compile3Menu;
    private javax.swing.JMenuItem compileMenu;
    private javax.swing.JMenu compilerMenu;
    private javax.swing.JMenuItem contentsMenuItem;
    private javax.swing.JMenuItem copyMenuItem;
    private javax.swing.JMenuItem cutMenuItem;
    private javax.swing.JMenuItem deleteMenuItem;
    private javax.swing.JMenu editMenu;
    private javax.swing.JMenuItem errorMenu;
    private javax.swing.JMenuItem exitMenuItem;
    private javax.swing.JMenu fileMenu;
    private javax.swing.JMenuItem grafoMenu;
    private javax.swing.JMenu helpMenu;
    private javax.swing.JPopupMenu.Separator jSeparator1;
    private javax.swing.JPopupMenu.Separator jSeparator2;
    private javax.swing.JMenuBar menuBar;
    private javax.swing.JMenuItem mirillaMenu;
    private javax.swing.JMenuItem newMenuItem;
    private javax.swing.JMenuItem openMenuItem;
    private javax.swing.JMenu optimizerMenu;
    private javax.swing.JMenuItem pasteMenuItem;
    private javax.swing.JMenuItem saveAsMenuItem;
    private javax.swing.JMenuItem saveMenuItem;
    private javax.swing.JMenuItem symtableMenu;
    private com.github.lproges.editor.gui.TabPane tabPane1;
    // End of variables declaration//GEN-END:variables

    SimTable gui_simtable = new SimTable(this, false);
    Errors gui_errors = new Errors(this, false);
}
